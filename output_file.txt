main.rs:
// main.rs
use regex_rustler::parser::parse_args;
use regex_rustler::process_file;
use std::io;

fn main() -> io::Result<()> {
    let config = parse_args();
    process_file(&config.file_path, &config.regex_pattern)
}


lib.rs:
// In lib.rs

use crate::processor::process_regex;
use anyhow::Result;
use fancy_regex::Regex;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
pub mod errors;
pub mod parser;
pub mod processor;
use errors::AppError;

pub fn process_file(file_path: &str, regex_pattern: &str) -> Result<()> {
    let file = File::open(file_path).map_err(AppError::FileReadError)?;
    let reader = BufReader::new(file);
    let regex = Regex::new(regex_pattern).map_err(AppError::RegexError)?;

    let mut toggle = false;

    for line in reader.lines() {
        let line = line.map_err(AppError::FileReadError)?;
        let processed_line = process_regex(&line, &regex, &mut toggle)?;
        println!("{}", processed_line);
    }

    Ok(())
}


processor.rs:
// In processor.rs
use crate::errors::AppError;
use anyhow::Result;
use colored::*;
use fancy_regex::Regex;

pub fn process_regex(line: &str, regex: &Regex, toggle: &mut bool) -> Result<String> {
    let mut new_line = String::new();
    let mut last = 0;

    // Iterate over the matches and handle each Result item
    let matches = regex.find_iter(line);
    for match_result in matches {
        let mat = match_result.map_err(AppError::RegexError)?;

        // Process each match
        new_line.push_str(&line[last..mat.start()]);
        let matched = if *toggle {
            mat.as_str().red().to_string()
        } else {
            mat.as_str().blue().to_string()
        };
        *toggle = !*toggle;
        new_line.push_str(&matched);
        last = mat.end();
    }

    new_line.push_str(&line[last..]);
    Ok(new_line)
}


config.rs:


errors.rs:
// errors.rs
use std::io;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("Error reading file: {0}")]
    FileReadError(#[from] io::Error),

    #[error("Error compiling regex: {0}")]
    RegexError(#[from] fancy_regex::Error),
}


parser.rs:
// src/parser.rs
use anyhow::anyhow;
use clap::{command, Arg};
pub struct Config {
    pub file_path: String,
    pub regex_pattern: String,
    pub real_time: bool,
}

pub fn parse_args() -> Result<Config> {
    let matches = command!()
        .author("Eyal Lampel")
        .about("Searches (and colors) for a regex pattern in a text file")
        .arg(
            Arg::new("file-path")
                .short('p')
                .long("path")
                .aliases(&["fpath", "path", "text-file", "file"])
                .value_name("FILE")
                .required(true)
                .help("Path to the Text file to search for example: /home/user/text.txt"),
        )
        .arg(
            Arg::new("regex-pattern")
                .short('r')
                .long("regex")
                .value_name("REGEX")
                .required(true)
                .help("Regex pattern to match for example: [a-z]"),
        )
        .arg(
            Arg::new("real-time-regex-testing")
                .short('t')
                .long("realTime")
                .aliases(&[
                    "rt",
                    "real-time",
                    "realtime",
                    "realTime",
                    "realTimeRegexTesting",
                ])
                .value_name("TEST")
                .required(false)
                .help("An argument to test your regex pattern in real time for example: [a-z]")
                //.value_hint(value_hint)
                .conflicts_with("regex-pattern"),
        )
        .get_matches();

    let file_path = matches
        .get_one::<String>("file-path")
        .ok_or_else(|| anyhow!("File path is required"))?
        .clone();
    let regex_pattern = matches
        .get_one::<String>("regex-pattern")
        .ok_or_else(|| anyhow!("Regex pattern is required"))?
        .clone();

    Ok(Config {
        file_path,
        regex_pattern,
        real_time: matches.args_present(),
    })
}


